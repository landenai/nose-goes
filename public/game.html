<!DOCTYPE html>
<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/phaser@v3.80.1/dist/phaser.min.js"></script>
  <script src="config.js"></script>
</head>

<body>
  <script>
    // ------- phaser painting -------- //
    class Example extends Phaser.Scene {
      constructor() {
        super();
        this.playerInstances = {};
        this.winners = {};
        this.nose = {};
      }

      drawNose({ x, y }) {
        this.nose = this.physics.add.image(x, y, 'nose');
      }

      checkForFinish() {

      }

      handleWSMessage(message) {
        try {
          const event = JSON.parse(message.data);

          switch (event.type) {
            case "initView":
              // sent on first connection
              // should paint everything
              if (event.gameState.nose) {
                this.drawNose(event.gameState.nose.currentLocation);
              }

              Object.keys(event.gameState.players).forEach(id => {
                this.playerInstances[id] = this.playerInit(event.gameState.players[id]);
              });
              break;
            case "initPlayer":
              // probably unneccessary check for non existence in game world
              if (!this.playerInstances[event.player.id]) {
                this.playerInstances[event.player.id] = this.playerInit(event.player);
              }
              break;
            case "move":
              // adjusts or resets every player (regardless of whether movement happened)
              const { players } = event.gameState;
              Object.keys(players).forEach(id => {
                const { position } = players[id];

                // move the player instance
                this.playerInstances[id].setPosition(position.x, position.y);

                // TODO: future?
                // add this position to a queue for this player
                // let interpolation move them
              });
              break;
            case "loser":
              console.log(`new loser: ${event.gameState.loserName}`);
              this.declareLoser(event.gameState.loserName)
              break;
          }
        } catch (e) {
          console.error('malformed game state!', e);
        }
      };

      preload() {
        this.load.path = 'assets/run/';

        this.load.image('run1', 'run1.png');
        this.load.image('run2', 'run2.png');
        this.load.image('run3', 'run3.png');
        this.load.image('run4', 'run4.png');

        this.load.path = 'assets/idle/';

        this.load.image('idle1', 'idle1.png');
        this.load.image('idle2', 'idle2.png');
        this.load.image('idle3', 'idle3.png');
        this.load.image('idle4', 'idle4.png');
        this.load.image('idle5', 'idle5.png');

        this.load.path = 'assets/nose/';

        this.load.svg('nose', 'nose.svg', { width: 100, height: 100 })
      }

      create() {
        this.anims.create({
          key: 'idle',
          frames: [
            { key: 'idle1' },
            { key: 'idle2' },
            { key: 'idle3' },
            { key: 'idle4' },
            { key: 'idle5', duration: 100 }

          ],
          frameRate: 8,
          repeat: -1
        });

        this.anims.create({
          key: 'run',
          frames: [
            { key: 'run1' },
            { key: 'run2' },
            { key: 'run3' },
            { key: 'run4', duration: 100 }

          ],
          frameRate: 8,
          repeat: -1
        });

        this.physics.world.on('overlap', (gameObject1, gameObject2, body1, body2) => {
          if (!gameObject1.isFinished) {
            gameObject1.isFinished = true;

            console.log(`OVERLAP: ${gameObject1.playerId} collided`);
            this.socket.send(JSON.stringify({
              type: "finish",
              data: {
                id: gameObject1.playerId,
              }
            }));


          }
        });

        this.socket = new WebSocket(CONFIG.websocketEndpoint);

        this.socket.addEventListener("open", (event) => {
          this.socket.send(JSON.stringify({ type: "initView" }));
        });

        this.socket.addEventListener("message", (message) => this.handleWSMessage(message));
      }

      playerInit({ name, position, id }) {
        console.log(`adding player w/ ID: ${id}`);

        // create the player sprite and add it to a container
        const playerSprite = this.add.sprite(0, 0, 'run1').play('run');
        playerSprite.setScale(1.2);
        const playerContainer = this.add.container(position.x, position.y, [playerSprite]);
        playerContainer.playerId = id;

        // add physics to player container
        this.physics.world.enableBody(playerContainer);
        playerContainer.body.onOverlap = true;
        this.physics.add.overlap(playerContainer, this.nose)

        // download the player avatar
        let rnd = name + Math.random();
        this.load.image({
          key: rnd,
          url: `https://api.dicebear.com/8.x/bottts/svg?seed=${name}`,
        });

        const scene = this;
        this.load.on(`filecomplete-image-${rnd}`, () => {
          // add face towards top of container
          const face = scene.add.image(0, -20, rnd);
          face.setScale(0.3);
          playerContainer.add(face);
        });
        this.load.start();

        console.log(`adding new player ${name}`);
        return playerContainer;
      }

      declareLoser(name) {
        const text = this.add.text(25, 250, `${name} loses! üêΩ`, {
          fontSize: '25px',
          color: '#000',
        });
      }

      // TODO: some text box thingy
      declareWinner(name) {
        const text = this.add.text(25, 250, `${name} is safe!`);
      }
    }

    const config = {
      type: Phaser.AUTO,
      parent: 'phaser-example',
      width: 1280,
      height: 700,
      backgroundColor: '#fbf0e4',
      physics: {
        default: 'arcade',
      },
      scene: Example
    };

    const game = new Phaser.Game(config);

  </script>


</body>

</html>
