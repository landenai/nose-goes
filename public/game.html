<!DOCTYPE html>
<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/phaser@v3.80.1/dist/phaser.min.js"></script>
  <script src="config.js"></script>
</head>

<body>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
  <script>
    // ------- phaser painting -------- //
    class NoseGoes extends Phaser.Scene {
      constructor() {
        super();
        this.playerInstances = {};
        this.winners = {};
        this.noseLocation = {}; // TODO: get this from server in `loser` message
        this.noseInstance = {}; // TODO: turn off visibility at game over
      }

      handleGameOver(name) {
        const text = this.add.text(0, 0, `${name} loses! ðŸ½`, {
          fontSize: '25px',
          color: '#000',
        });
        text.setOrigin(0.5, 0.2); // center-top
        this.removeNose();
      }

      // show a countdown timer and kick off the next game
      handleIntermission(loserText) {
        // display a countdown timer
        let secondsLeft = 10;
        const countdownString = `New Round\nstarts in\n${secondsLeft}`;
        const countdownText = this.add.text(0, 0, countdownString);
        countdownText.setOrigin(0.5, 0.5); // center-center

        const decrementCountdown = () => {
          secondsLeft -= 1;
          countdownText.setText(countdownString);

          if (secondsLeft <= 0) {
            this.newGame();
          } else {
            setTimeout(decrementCountdown, 1000);
          }
        };

        setTimeout(decrementCountdown, 1000);

      }

      newGame() {
        // re-enable all players (w/ jitter?)
        // render the new nose
        drawNose(this.nose);

        // reset state
      }

      drawNose({ x, y }) {
        this.noseInstance = this.physics.add.image(x, y, 'nose');
      }

      removeNose() {
        this.noseInstance.destroy();
      }

      handleWSMessage(message) {
        try {
          const event = JSON.parse(message.data);

          switch (event.type) {
            case "initView":
              // sent on first connection
              // should paint everything
              if (event.gameState.nose) {
                this.drawNose(event.gameState.nose.currentLocation);
              }

              Object.keys(event.gameState.players).forEach(id => {
                this.playerInstances[id] = this.playerInit(event.gameState.players[id]);
              });
              break;
            case "initPlayer":
              // probably unneccessary check for non existence in game world
              if (!this.playerInstances[event.player.id]) {
                this.playerInstances[event.player.id] = this.playerInit(event.player);
              }
              break;
            case "move":
              // adjusts or resets every player (regardless of whether movement happened)
              const { players } = event.gameState;
              Object.keys(players).forEach(id => {
                const { position } = players[id];
                // move the player instance
                this.playerInstances[id].setPosition(position.x, position.y);

                // TODO: future?
                // add this position to a queue for this player
                // let interpolation move them
              });
              break;
            case "loser":
              const loser = this.playerInstances[event.id];
              console.log(`new loser: ${loser.name}`);

              const loserText = this.handleGameOver(loser.name);
              this.handleIntermission(loserText);

              break;
          }
        } catch (e) {
          console.error('malformed game state!', e);
        }
      };

      preload() {

        this.load.path = 'assets/'
        this.load.image('qrCode', 'qr_code.png');
        this.load.image('spawnPoint', 'spawn_point.png');

        this.load.path = 'assets/run/';

        this.load.image('run1', 'run1.png');
        this.load.image('run2', 'run2.png');
        this.load.image('run3', 'run3.png');
        this.load.image('run4', 'run4.png');

        this.load.path = 'assets/idle/';

        this.load.image('idle1', 'idle1.png');
        this.load.image('idle2', 'idle2.png');
        this.load.image('idle3', 'idle3.png');
        this.load.image('idle4', 'idle4.png');
        this.load.image('idle5', 'idle5.png');

        this.load.path = 'assets/nose/';

        this.load.svg('nose', 'nose.svg', { width: 100, height: 100 })
      }

      create() {
        const qrCode = this.add.sprite(70, 70, 'qrCode');
        qrCode.setScale(.5);

        const spawnPoint = this.add.sprite(200, 50, 'spawnPoint');
        spawnPoint.setScale(.25);

        this.anims.create({
          key: 'idle',
          frames: [
            { key: 'idle1' },
            { key: 'idle2' },
            { key: 'idle3' },
            { key: 'idle4' },
            { key: 'idle5', duration: 100 }

          ],
          frameRate: 8,
          repeat: -1
        });

        this.anims.create({
          key: 'run',
          frames: [
            { key: 'run1' },
            { key: 'run2' },
            { key: 'run3' },
            { key: 'run4', duration: 100 }

          ],
          frameRate: 8,
          repeat: -1
        });

        this.physics.world.on('overlap', (playerContainer, _gameObject2, _body1, _body2) => {
          if (!playerContainer.isFinished) {
            playerContainer.isFinished = true;

            console.log(`OVERLAP: ${playerContainer.playerId} collided`);
            this.socket.send(JSON.stringify({
              type: "finish",
              data: {
                id: playerContainer.playerId,
              }
            }));

            this.declareSafe(playerContainer.name);
          }
        });

        this.socket = new WebSocket(CONFIG.websocketEndpoint);

        this.socket.addEventListener("open", (event) => {
          this.socket.send(JSON.stringify({ type: "initView" }));
        });

        this.socket.addEventListener("message", (message) => this.handleWSMessage(message));
      }

      playerInit({ name, position, id }) {
        console.log(`adding player w/ ID: ${id}`);

        // create the player sprite and add it to a container
        const playerSprite = this.add.sprite(0, 0, 'run1').play('run');
        playerSprite.setScale(1.2);
        const playerContainer = this.add.container(position.x, position.y, [playerSprite]);
        playerContainer.playerId = id;
        playerContainer.name = name;

        // add physics to player container
        this.physics.world.enableBody(playerContainer);
        playerContainer.body.onOverlap = true;
        this.physics.add.overlap(playerContainer, this.noseInstance)

        // download the player avatar
        let rnd = name + Math.random();
        this.load.image({
          key: rnd,
          url: `https://api.dicebear.com/8.x/bottts/svg?seed=${name}`,
        });

        const scene = this;
        this.load.on(`filecomplete-image-${rnd}`, () => {
          // add face towards top of container
          const face = scene.add.image(0, -20, rnd);
          face.setScale(0.3);
          playerContainer.add(face);
        });
        this.load.start();

        console.log(`adding new player ${name}`);
        return playerContainer;
      }

      declareSafe(name) {
        // get random px b/w 750 and 850
        const WIN_MAX = 850;
        const WIN_MIN = 750;
        const xPos = Math.random() * (WIN_MAX - WIN_MIN) + WIN_MAX;

        const text = this.add.text(xPos, 250, `${name} is safe!`, {
          fontSize: '20px',
          color: '#000',
        });
        this.physics.world.enableBody(text);
        this.physics.moveTo(text, xPos, -20);
      }
    }

    const config = {
      type: Phaser.AUTO,
      parent: 'phaser-example',
      width: 1280,
      height: 700,
      backgroundColor: '#fbf0e4',
      physics: {
        default: 'arcade',
      },
      scene: NoseGoes
    };

    const game = new Phaser.Game(config);

  </script>


</body>

</html>